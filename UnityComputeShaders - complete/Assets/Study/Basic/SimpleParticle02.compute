// Each #kernel tells which function to compile; you can have many kernels
// 1. 커널 정의 (이 함수를 실행하겠다!) 커널은 일꾼들이 동시에 실행하는 함수이고 일꾼들이 이 커널 즉 CSMain 을 실행하겠다라는 뜻이다.
#pragma kernel CSMain


// 2. 데이터 구조 (C#이랑 약속한 모양 - 렌더 쉐이더랑 똑같아야 함)
struct Particle
{
    float3 position;
    float3 color;
};

// 3. 읽고 쓸 수 있는 택배 상자 (RW = Read/Write) RWStructuredBuffer 는 형식이 정해진 타입드 어레이 이다.TypedArray(형식화 배열)
RWStructuredBuffer<Particle> particleBuffer;

// 4. 외부에서 시간 값을 받아옴 (움직이게 하려고)
float time;


// 랜덤 생성기 (0.0 ~ 1.0 사이의 값을 반환)
// co: 씨앗(Seed) 값. 이 값이 다르면 결과도 달라짐.
float rand(float2 co)
{
    return frac(sin(dot(co.xy, float2(12.9898, 78.233))) * 43758.5453);
}


// 5. 스레드 설정 (64명이 한 조)
[numthreads(64,1,1)]

//GPU에는 for문이 없다 그래서 uint3 id : SV_DispatchThreadID 를 사용한다.
//SV_DispatchThreadID 는 
//SV: System Value (시스템 값). "GPU야, 이건 내가 계산하는 게 아니라 네가 내부적으로 관리하는 값이야."
//DispatchThreadID: 전체 작업 공간에서의 절대적인 번호(ID).
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!

    // 내 번호표 (0 ~ 9999...)
    uint index = id.x;

    // 1. [중요] 상자를 열어서 기존 데이터를 꺼내옵니다.
    // (그래야 "기존 y값"이 뭔지 알 수 있습니다)
    Particle p = particleBuffer[index];

    // index를 씨앗으로 써서 랜덤 값을 뽑음 (0.0 ~ 1.0)
    // * 10.0 : 범위를 0 ~ 10으로 늘림
    // - 5.0  : 범위를 -5 ~ 5로 이동 (중앙 정렬)
    float x = rand(float2(index, 0)) * 10.0 - 5.0;

    // 속도도 랜덤하게! (구분자로 1을 사용)
    // 0.01(최소) ~ 0.06(최대) 사이의 속도
    float speed = rand(float2(index, 1)) * 0.05 + 0.01;
    float y = p.position.y + speed;

    // (옵션) 너무 높이 가면 다시 바닥으로 (안 그러면 하늘 뚫고 나갑니다)
    if (y > 10.0) y = 0.0;

    // X랑 똑같은데 구분자만 '2'로 바꿔서 다른 랜덤값 뽑기
    float z = rand(float2(index, 2)) * 10.0 - 5.0;

    particleBuffer[index].position = float3(x, y, z);

    // 색깔은 무조건 흰색(1,1,1)으로 고정
    particleBuffer[index].color = float3(1, 1, 1);
}
